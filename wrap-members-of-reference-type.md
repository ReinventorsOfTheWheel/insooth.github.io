

# Wrap members of reference type for great good

There is nothing unusual in passing value by reference, or even using reference as a function result type (provided that it does not point to a value of [automatic storage duration](http://en.cppreference.com/w/cpp/language/storage_duration)). References can be understood as non-rebindable pointers (i.e `T* const`) in general.

We can quickly run into surprising behaviour once we decide to have a member of a reference type. Reference members alter the way compiler generates special member functions. How reference members interact with other members strictly depends on the concepts modelled by members' types. Same holds true for wrapping types with reference members into other types (like `vector`), or applying some of the well-known library functions.

## Really cannot rebind

*Once initialized, a reference cannot be changed to refer to another object* says [reference](http://en.cppreference.com/w/cpp/language/reference_initialization). Curious user may write:

```c++
int i = 100;
int& ri = i;
int j = 200;
ri = j;
```

which compiles fine and **looks** like if it were rebinding reference, but in fact it does something completely different to one may think. If we print value of `i` we will see that we have changed its value to value of `j`. Bound address of `ri` remained unchanged. Unfortunately, there is no compiler warning, even in `-Wextra` mode.

## As a member

Some member functions like wide variety of constructors, assignment operators and destructors are auto-generated by compiler under *certain circumstances*. Members of reference types, even in derived on deeply nested types, may easily, and usually do, limit the number of auto-generated special member functions.

### Constructing

Type with a reference member is non-[`DefaultConstructible`](http://en.cppreference.com/w/cpp/concept/DefaultConstructible) unless we explicitly specify default initialiser for each reference member. Such behaviour is exactly what we want for a reference: it guarantees that always points to a valid address, thus there is not need to check against `nullptr` as it is required for pointers before dereferencing.

This will not work:

```c++
struct A
{
    int& i;
};

A a; // error: uninitialized reference member in 'struct A'
     // note: 'A::A()' is implicitly deleted because the default definition would be ill-formed
```

while this requires `const` reference (which is extremely bad idea) or global variable (which is really bad idea):


```c++

int g = 300;

struct A
{
    int& i = g;

    // having:
    //   int& j = 400;
    // compiler will guide user to add "const"...
    const int& j = 400;
    // ...which will result in real bug:
    //   warning: a temporary bound to 'A::j' only persists until the constructor exits [-Wextra]
};
```

If `g` is a resource that can be unloaded at any point in time (like `shared_ptr`), then we violate basic reference guarantee and we have reference to rubbish. That is a serious bug in the runtime not possible to be detected by compiler today.

### Assigning

Since reference cannot be rebinded, neither copy-assignment nor move-assignment operators are generated. That puts constraint on the whole type and anyone that composes with it: such types are non-[`CopyAssignable`](http://en.cppreference.com/w/cpp/concept/CopyAssignable) and non-[`MoveAssignable`](http://en.cppreference.com/w/cpp/concept/MoveAssignable) (which is implied from first, since `Copy*` requires `Move*` concept to be satisfied first).

```c++
struct A
{
    int& i;
};

int j = 100;
A a{j};

int k = 200;
A aa{k};

aa = a; // error: non-static reference member 'int& A::i', can't use default assignment perator
        // note: 'A& A::operator=(const A&)' is implicitly deleted because the default definition would be ill-formed
```

Similar consequences introduce `const` members which can be assigned only once (and never reassigned).

## Cycles invalidate references

If we introduce reference members to member in the same object we are likely to inject nasty bug. Consider what will happen if `std::move` fails here (and it really fallbacks to copy):

```c++
struct B
{
    int i;
    int& j = i;
};

int k = 100;
B b{k};
B bb{std::move(b)};
```

Reference `bb.j` still points to `b.i`, so that if `b` goes out of scope, it will point to rubbish. Rule of thumb is: never make references to itself, and if you really have to, make type non-copyable.

## Interaction

More derived or direct members of different types we have gathered in a class, the more different type concepts may interact with each other. That, in turn, sometimes alters auto-generation of special member functions in non-obvious way.

Let's try to [`swap`](http://en.cppreference.com/w/cpp/algorithm/swap) `unique_ptr` with custom deleter with member of a reference type.

```c++
struct D
{
    int& i;
    void operator() (int* p) { delete p; }
};

using P = std::unique_ptr<int, D>;

int j = 100;
int k = 100;
P p{nullptr, D{j}};
P pp{nullptr, D{k}};

pp.swap(p);  // error: no matching function for call to 'swap(D&, D&)'
```

Few line later (whole error may be of several screens long) decent compiler says:

```
note: candidate: template<class _Tp> typename std::enable_if<std::__and_<std::is_move_constructible<_Tp>, std::is_move_assignable<_Tp> >::value>::type std::swap(_Tp&, _Tp&)
...
[with _Tp = D]
```

that can be interpreted as information about concept violation by `D` while attempting to use `swap` on `P`.

In fact, [`swap`](http://en.cppreference.com/w/cpp/algorithm/swap) on values of type `T` requires type `T` to be a model of [`MoveConstructible`](http://en.cppreference.com/w/cpp/concept/MoveConstructible) and [`MoveAssignable`](http://en.cppreference.com/w/cpp/concept/MoveAssignable) concepts (move has natural fallback to copy anyway). `D` is definitely not a model of `MoveAssignable` since it contains a reference, thus it does not swap.

There are several ways to fix this. The worst of them is to make a change from reference to a pointer type. Using a bare pointer will expand domain of `D::i` with `nullptr`, i.e. we will loose the best of reference types.

There is a way to model `CopyAssignable` (which satisfies `MoveAssignable` too) concept and keep the reference guarantees, it is called [`std::reference_wrapper`](http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper). This will work as expected:

```c++
struct D
{
    std::reference_wrapper<int> i;

    void operator() (int* p) { delete p; }
};

using P = std::unique_ptr<int, D>;

int j = 100;
int k = 100;
P p{nullptr, D{ std::ref(j) }};
P pp{nullptr, D{ std::ref(k) }};
pp.swap(p);
```

Moreover, wrapping into `reference_wrapper` is the only way to store references in the STL containers.

## Variance

`std::reference_wrapper<T>` is covariant as much as regular reference is. That means following is possible:

```c++
struct A {};
struct B : A {};

B b;
std::reference_wrapper<A>        p{b};
//                     ^~~ base    ^~~ derived (covariant to A)
```

but it does not work through `std::ref` (or `std::cref`) helpers:

```c++
void foo(std::reference_wrapper<A>) {}

B b;
foo(std::ref(b)); // error: could not convert 'std::ref<B>(b)' from 'std::reference_wrapper<B>' to 'std::reference_wrapper<A>'
```

We need either `static_cast` `b` to `A&` in `std::ref` or use conversion constructor:

```c++
void foo(std::reference_wrapper<A>) {}

B b;
foo(b);
```

## Wrap members

References are great. They eliminate multitude of bugs (runtime crashes literally) by simply shrinking domain of a value (eliminating [the billion-dollar mistake](https://en.wikipedia.org/wiki/Tony_Hoare)). References are limiting if stored as members. Reference wrappers are not.

Type produced by `std::reference_wrapper` is guaranteed to be [`TriviallyCopyable`](http://en.cppreference.com/w/cpp/concept/TriviallyCopyable), i.e. can be copied with `memcpy`. What is copied is the bare pointer stored internally, whole abstraction is for type system only.

#### About this document

December 9, 2016 &mdash; Krzysztof Ostrowski

